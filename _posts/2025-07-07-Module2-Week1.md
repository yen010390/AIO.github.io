---
title: 'Module 02 - Week 01 -  N·ªôi dung'
excerpt: "ƒê·∫°i s·ªë tuy·∫øn t√≠nh c∆° b·∫£n v√† Numpy"
date: 2025-07-07
tags:
  - numpy
---
**T√°c gi·∫£**: Nguy·ªÖn Tu·∫•n Anh - ƒêo√†n T·∫•n H∆∞ng - H·ªì Th·ªã Ng·ªçc Huy·ªÅn - Tr·∫ßn Th·ªã M·ªπ T√∫ - ƒê·∫∑ng Th·ªã Ho√†ng Y·∫øn

**Nh√≥m**: MIX002 - AIO 2025

**M·ª•c l·ª•c** 
- [1. T√≥m t·∫Øt n·ªôi dung](#1-t√≥m-t·∫Øt-n·ªôi-dung)
- [2. C∆° s·ªü l√Ω thuy·∫øt](#2-c∆°-s·ªü-l√Ω-thuy·∫øt)
  - [2.1 Numpy - c∆° b·∫£n](#21-numpy---c∆°-b·∫£n)
    - [2.1.1 Numpy l√† g√¨](#211-numpy-l√†-g√¨)
    - [2.1.2 So s√°nh List v√† NumPy Array](#212-so-s√°nh-list-v√†-numpy-array)
    - [2.1.3 M·ªôt s·ªë k·ªπ thu·∫≠t n√¢ng cao v·ªõi Numpy](#213-m·ªôt-s·ªë-k·ªπ-thu·∫≠t-n√¢ng-cao-v·ªõi-numpy)
    - [2.1.4 M·ªôt s·ªë k·ªπ thu·∫≠t l·∫≠p tr√¨nh ph·ªï bi·∫øn v·ªõi NumPy](#214-m·ªôt-s·ªë-k·ªπ-thu·∫≠t-l·∫≠p-tr√¨nh-ph·ªï-bi·∫øn-v·ªõi-numpy)
  - [2.2 Bi·ªÉu di·ªÖn d·ªØ li·ªác d·∫°ng vector 2D/3D v·ªõi Numpy](#22-bi·ªÉu-di·ªÖn-d·ªØ-li·ªác-d·∫°ng-vector-2d3d-v·ªõi-numpy)
- [3. ·ª®ng d·ª•ng](#3-·ª©ng-d·ª•ng)
- [4. Th·∫£o lu·∫≠n v√† m·ªü r·ªông](#4-th·∫£o-lu·∫≠n-v√†-m·ªü-r·ªông)
- [5. K·∫øt lu·∫≠n](#5-k·∫øt-lu·∫≠n)
- [6. T√†i li·ªáu tham kh·∫£o](#6-t√†i-li·ªáu-tham-kh·∫£o)


# 1. T√≥m t·∫Øt n·ªôi dung

# 2. C∆° s·ªü l√Ω thuy·∫øt
## 2.1 Numpy - c∆° b·∫£n
### 2.1.1 Numpy l√† g√¨

**NumPy** (vi·∫øt t·∫Øt c·ªßa *Numerical Python*) l√† m·ªôt th∆∞ vi·ªán m√£ ngu·ªìn m·ªü trong Python, chuy√™n d√πng ƒë·ªÉ:

- L√†m vi·ªác v·ªõi **m·∫£ng nhi·ªÅu chi·ªÅu**.
- Th·ª±c hi·ªán c√°c ph√©p **t√≠nh to√°n s·ªë h·ªçc hi·ªáu nƒÉng cao**.
- H·ªó tr·ª£ c√°c thao t√°c to√°n h·ªçc, th·ªëng k√™, ƒë·∫°i s·ªë tuy·∫øn t√≠nh, x·ª≠ l√Ω t√≠n hi·ªáu, v.v.

> üîß NumPy l√† n·ªÅn t·∫£ng c·ªët l√µi cho c√°c th∆∞ vi·ªán l·ªõn nh∆∞ **Pandas, Scikit-learn, TensorFlow, PyTorch**,.. cho n√™n vi·ªác hi·ªÉu v√† v√† s·ª≠ d·ª•ng thu·∫ßn th·ª•c numpy l√† m·ªôt y·∫øu t·ªë kh√¥ng th·ªÉ thi·∫øu ƒë·ªÉ ƒë·ªçc hi·ªÉu v√† l·∫≠p tr√¨nh trong c√°c ·ª©ng d·ª•ng v√† m√¥ m√¨nh h·ªçc m√°y. 

### 2.1.2 So s√°nh List v√† NumPy Array
Trong Python, ki·ªÉu d·ªØ li·ªáu List v√† NumPy Array ƒë·ªÅu c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ v√† truy xu·∫•t d·ªØ li·ªáu d·∫°ng m·∫£ng.
Tuy nhi√™n, hai ki·ªÉu d·ªØ li·ªáu n√†y ph·ª•c v·ª• v√† ƒë∆∞·ª£c t·ªëi ∆∞u cho nh·ªØng m·ª•c ƒë√≠ch kh√°c nhau:
- **List**: Cho ph√©p ch·ª©a nhi·ªÅu ki·ªÉu d·ªØ li·ªáu kh√°c nhau (kh√¥ng ƒë·ªìng nh·∫•t) nh∆∞ chu·ªói, s·ªë nguy√™n, s·ªë th·ª±c, boolean, ho·∫∑c danh s√°ch l·ªìng nhau. ƒê√¢y l√† ki·ªÉu d·ªØ li·ªáu linh ho·∫°t trong Python, nh∆∞ng ch·ªâ h·ªó tr·ª£ m·ªôt chi·ªÅu truy c·∫≠p (m·ªôt ch·ªâ s·ªë). Ngo√†i ra, List kh√¥ng ƒë∆∞·ª£c t·ªëi ∆∞u cho c√°c ph√©p t√≠nh s·ªë h·ªçc ho·∫∑c x·ª≠ l√Ω d·ªØ li·ªáu hi·ªáu nƒÉng cao.
- **NumPy Array:** L√† t·ªïng qu√°t h√≥a c·ªßa vector trong to√°n h·ªçc. Array ho·∫°t ƒë·ªông hi·ªáu qu·∫£ trong vi·ªác bi·ªÉu di·ªÖn d·ªØ li·ªáu nhi·ªÅu chi·ªÅu th√¥ng qua ch·ªâ s·ªë nhi·ªÅu chi·ªÅu nh∆∞ A[i, j] (2D), B[i, j, k] (3D),... ƒê√¢y l√† ki·ªÉu d·ªØ li·ªáu ƒë·ªìng nh·∫•t ‚Äì t·∫•t c·∫£ ph·∫ßn t·ª≠ ph·∫£i c√πng ki·ªÉu ‚Äì v√† ƒë∆∞·ª£c t·ªëi ∆∞u cho t√≠nh to√°n s·ªë h·ªçc cho n√™n r·∫•t ph√π h·ª£p v·ªõi vi·ªác t√≠nh to√°n trong  khoa h·ªçc d·ªØ li·ªáu, v√† c√°c ·ª©ng d·ª•ng AI/ML.

Ta c√≥ th·ªÉ t·ªïng h·ª£p l·∫°i c√°c ƒëi·ªÉm kh√°c bi·ªát ch√≠nh gi·ªØa list v√† Numpy Array nh∆∞ sau: 

| Ti√™u ch√≠                          | Python List                                           | NumPy Array                                                           |
| --------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------- |
| **T√≠nh ƒë·ªìng nh·∫•t (ki·ªÉu d·ªØ li·ªáu)** | C√≥ th·ªÉ ch·ª©a **nhi·ªÅu ki·ªÉu d·ªØ li·ªáu** kh√°c nhau          | Ch·ªâ ch·ª©a **m·ªôt ki·ªÉu d·ªØ li·ªáu duy nh·∫•t** (ƒë·ªìng nh·∫•t)                    |
| **K√≠ch th∆∞·ªõc ƒë·ªông**               | C√≥ th·ªÉ thay ƒë·ªïi linh ho·∫°t (th√™m, x√≥a ph·∫ßn t·ª≠)         | C√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh sau khi t·∫°o (mu·ªën thay ƒë·ªïi c·∫ßn t·∫°o array m·ªõi)   |
| **ƒêa chi·ªÅu (multi-dimensional)**  | H·∫°n ch·∫ø ‚Äì c·∫ßn s·ª≠ d·ª•ng nested list                     | H·ªó tr·ª£ m·∫°nh m·∫Ω m·∫£ng nhi·ªÅu chi·ªÅu (2D, 3D, ...)                         |
| **Hi·ªáu su·∫•t t√≠nh to√°n**           | Ch·∫≠m h∆°n, kh√¥ng t·ªëi ∆∞u cho t√≠nh to√°n s·ªë l∆∞·ª£ng l·ªõn     | R·∫•t nhanh v√† hi·ªáu qu·∫£ nh·ªù s·ª≠ d·ª•ng C-level backend v√† vectorization    |
| **B·ªô nh·ªõ (Memory)**               | Kh√¥ng l∆∞u tr·ªØ li√™n t·ª•c trong b·ªô nh·ªõ                   | D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ **li√™n ti·∫øp** trong b·ªô nh·ªõ ‚Üí truy xu·∫•t nhanh h∆°n |
| **·ª®ng d·ª•ng ƒëi·ªÉn h√¨nh**            | L∆∞u tr·ªØ d·ªØ li·ªáu h·ªón h·ª£p, logic x·ª≠ l√Ω chung            | Ph√¢n t√≠ch d·ªØ li·ªáu s·ªë, AI/ML, x·ª≠ l√Ω ·∫£nh, to√°n h·ªçc t√≠nh to√°n cao c·∫•p    |
| **Th∆∞ vi·ªán h·ªó tr·ª£**               | Kh√¥ng c·∫ßn import                                      | C·∫ßn `import numpy as np`                                              |
| **C√°c ph√©p to√°n s·ªë h·ªçc**          | Kh√¥ng h·ªó tr·ª£ tr·ª±c ti·∫øp: ph·∫£i vi·∫øt v√≤ng l·∫∑p            | H·ªó tr·ª£ s·∫µn: `a + b`, `a * b`, `np.dot(a, b)`, `np.sum(a)`, ...        |
| **H·∫°n ch·∫ø ch√≠nh**                 | Kh√¥ng t·ªëi ∆∞u cho t√≠nh to√°n l·ªõn; kh√¥ng c√≥ broadcasting | Kh√¥ng linh ho·∫°t ki·ªÉu d·ªØ li·ªáu; c·∫ßn chuy·ªÉn ƒë·ªïi khi c·∫ßn ki·ªÉu h·ªón h·ª£p     |

<br>
C√°c API l·∫≠p tr√¨nh ch√≠nh khi l√†m vi·ªác gi·ªØa List v√† Numpy Array ƒë∆∞·ª£c ƒë·ªëi chi·∫øu nh∆∞ sau: 


| T√°c v·ª•                                | Python List                               | NumPy Array                                                                   |
| ------------------------------------- | ----------------------------------------- | ----------------------------------------------------------------------------- |
| **T·∫°o m·∫£ng**                          | `l = [1, 2, 3]`                           | `a = np.array([1, 2, 3])`                                                     |
| **Indexing & Slicing**                | `l[1]`, `l[1:3]`, `l[::-1]`               | `a[1]`, `a[1:3]`, `a[::-1]`                                                   |
| **Th√™m ph·∫ßn t·ª≠**                      | `l.append(4)`, `l.insert(0, 0)`           | `np.append(a, 4)`, `np.insert(a, 0, 0)`                                       |
| **C·∫≠p nh·∫≠t ph·∫ßn t·ª≠**                  | `l[1] = 10`                               | `a[1] = 10`                                                                   |
| **To√°n t·ª≠ `+`, `*`**                  | `l + l2` ‚Üí n·ªëi list<br>`l * 2` ‚Üí l·∫∑p l·∫°i  | `a + a2` ‚Üí c·ªông ph·∫ßn t·ª≠<br>`a * 2` ‚Üí nh√¢n ph·∫ßn t·ª≠                             |
| **S·∫Øp x·∫øp**                           | `l.sort()`, <br> `l.sort(reverse=True)`   | Kh√¥ng c√≥ x·∫Øp x·∫øp gi·∫£m d·∫ßn <br> `a.sort()`, <br>`a[::-1]` (ƒë·∫£o ng∆∞·ª£c sau sort) |
| **X√≥a ph·∫ßn t·ª≠**                       | `l.pop(1)`, `del l[1]`, `l.remove(3)`     | `np.delete(a, 1)`<br>`np.delete(a, np.where(a==3))`                           |
| **T√¨m ch·ªâ s·ªë (`index`)**              | `l.index(3)`                              | `np.where(a == 3)[0][0]`                                                      |
| **ƒê·∫øm v√† sao ch√©p (`count`, `copy`)** | `l.count(3)`, `l.copy()`                  | `np.sum(a == 3)`, `a.copy()`                                                  |
| **`len()`, `min()`, `max()`**         | `len(l)`, `min(l)`, `max(l)`              | `len(a)`, `np.min(a)`, `np.max(a)`                                            |
| **K√≠ch th∆∞·ªõc (`shape`)**              | Kh√¥ng c√≥ thu·ªôc t√≠nh `shape`               | `a.shape` ‚Üí cho bi·∫øt s·ªë chi·ªÅu v√† k√≠ch th∆∞·ªõc                                   |
| **T·ªïng (`sum`)**                      | `sum(l)`                                  | `np.sum(a)`                                                                   |
| **Zip `zip()`**                       | Kh√¥ng h·ªó tr·ª£ zip <br> `list(zip(l1, l2))` | `np.stack([a1, a2], axis=1)` / `np.column_stack()`                            |
| **Enumerate `enumerate()`**           | `enumerate(l)`                            | `np.ndenumerate(a)`                                                           |
| **D·ªØ li·ªáu 2D**                        | `[[1, 2], [3, 4]]`                        | `np.array([[1, 2], [3, 4]])`                                                  |


<br>

> üß† **T·ªïng k·∫øt**:  
> - **List** th√≠ch h·ª£p cho d·ªØ li·ªáu h·ªón h·ª£p ho·∫∑c logic linh ho·∫°t.  
> - **NumPy Array** ƒë∆∞·ª£c thi·∫øt k·∫ø chuy√™n bi·ªát cho hi·ªáu nƒÉng cao v√† x·ª≠ l√Ω d·ªØ li·ªáu s·ªë v·ªõi k√≠ch th∆∞·ªõc l·ªõn/multidimensional ‚Äî r·∫•t ph√π h·ª£p trong khoa h·ªçc d·ªØ li·ªáu v√† AI.

### 2.1.3 M·ªôt s·ªë k·ªπ thu·∫≠t n√¢ng cao v·ªõi Numpy
**‚úÖ Integer Array Indexing**: B·∫°n c√≥ th·ªÉ ch·ªçn nhi·ªÅu ph·∫ßn t·ª≠ theo ch·ªâ s·ªë c·ª• th·ªÉ:

```python
a = np.array([10, 20, 30, 40, 50])
idx = [1, 3]
result = a[idx]  # [20, 40]
```

**‚úÖ Boolean Array Indexing**: L·ªçc ph·∫ßn t·ª≠ d·ª±a tr√™n ƒëi·ªÅu ki·ªán
```python
a = np.array([1, 2, 3, 4, 5])
mask = a > 3
filtered = a[mask]  # [4, 5]
```
**‚úÖ Array Manipulation - Reshape**: Thay ƒë·ªïi shape m·∫£ng m√† kh√¥ng thay ƒë·ªïi d·ªØ li·ªáu
```python
a = np.array([1, 2, 3, 4, 5, 6])
a_reshaped = a.reshape((2, 3))
```
**‚úÖ Array Manipulation - Flatten**: Chuy·ªÉn array nhi·ªÅu chi·ªÅu th√†nh 1 chi·ªÅu
```python
a = np.array([[1, 2], [3, 4]])
flat = a.flatten()  # [1 2 3 4]
```
**‚úÖ  Concatenate & Stack**: G·ªôp m·∫£ng
```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])

np.vstack((a, b))  # G·ªôp theo chi·ªÅu d·ªçc
np.hstack((a, b.T))  # G·ªôp theo chi·ªÅu ngang
```
**‚úÖ Broadcasting**: cho ph√©p b·∫°n th·ª±c hi·ªán ph√©p to√°n tr√™n c√°c array c√≥ shape kh√¥ng gi·ªëng nhau m√† kh√¥ng c·∫ßn v√≤ng l·∫∑p
```python
a = np.array([[1], [2], [3]])  # shape (3,1)
b = np.array([10, 20, 30])     # shape (3,)
result = a + b  # shape (3,3)

```
> L∆∞u √Ω: NumPy s·∫Ω m·ªü r·ªông m·∫£ng nh·ªè h∆°n theo chi·ªÅu c·∫ßn thi·∫øt
>

**‚úÖ Vectorization** t·ªëi ∆∞u hi·ªáu nƒÉng nhi·ªÅu l·∫ßn so v·ªõi v√≤ng l·∫∑p truy·ªÅn th·ªëng

üò≠ C√°ch kh√¥ng t·ªëi ∆∞u

```python
result = []
for x in a:
    result.append(x ** 2)

```

üòä C√°ch t·ªëi ∆∞u b·∫±ng Vectorization

```python
result = a ** 2
```

üòä B·∫°n c√≥ th·ªÉ d√πng Vectorization v·ªõi np.sin, np.exp, np.log tr√™n to√†n b·ªô array:
```python
x = np.linspace(0, 2 * np.pi, 1_000_000)
y = np.sin(x) * np.exp(-x)
```

**Sau ƒë√¢y l√† m·ªôt s·ªë benchmark** khi √°p d·ª•ng Vectorization  gi√∫p tƒÉng t·ªëc ƒë·ªô l√™n g·∫•p nhi·ªÅu l·∫ßn. 

**‚è±Ô∏è ƒê√°nh gi√° 01**: `ùëì(ùë•) = sinùë•*ùëí^‚àíùë•`, khi ch·∫°y tr√™n Google colab, s·ª≠ d·ª•ng Vectorization tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω l√™n 12.42 l·∫ßn

![Vectorization Benchmark 01]({{ site.baseurl }}/images/m02/w01/numpy-vectorization-benchmark01-sinxe.png "Vectorization Benchmark")

**‚è±Ô∏è ƒê√°nh gi√° 02**: t·ªëc ƒë·ªô x·ª≠ l√Ω nhanh h∆°n 41 l·∫ßn.

![Vectorization Benchmark 01]({{ site.baseurl }}/images/m02/w01/numpy-vectorization-benchmark02.png "Vectorization Benchmark")

### 2.1.4 M·ªôt s·ªë k·ªπ thu·∫≠t l·∫≠p tr√¨nh ph·ªï bi·∫øn v·ªõi NumPy
**‚úÖ Stack two arrays vertically**

G·ªôp nhi·ªÅu m·∫£ng theo chi·ªÅu d·ªçc (tƒÉng s·ªë d√≤ng). C·∫ßn ƒë·∫£m b·∫£o s·ªë c·ªôt gi·ªëng nhau.

```python
import numpy as np

a = np.array([[0, 1, 2], [3, 4, 5]])
b = np.array([[6, 7, 8]])

result = np.vstack((a, b))
```
**‚úÖ Stack two arrays horizontally**

G·ªôp nhi·ªÅu m·∫£ng theo chi·ªÅu ngang (tƒÉng s·ªë c·ªôt). C·∫ßn ƒë·∫£m b·∫£o s·ªë d√≤ng gi·ªëng nhau.

```python
a = np.array([[0, 1, 2], [3, 4, 5]])
b = np.array([[6], [7]])

result = np.hstack((a, b))

```

**‚úÖ Take all elements satisfying with a given predefined condition**

L·ªçc d·ªØ li·ªáu b·∫±ng ƒëi·ªÅu ki·ªán logic (boolean indexing):
```python
arr = np.array([1, 8, 2, 5, 4, 6, 0, 7, 9, 3])
filtered = arr[arr < 7]  # array([1, 2, 5, 4, 6, 0, 3])
```

**‚úÖ Apply a user-defined function for array**

B·∫°n c√≥ th·ªÉ √°p d·ª•ng h√†m t·ª± ƒë·ªãnh nghƒ©a b·∫±ng np.vectorize ho·∫∑c np.where.

```python
def custom_func(x):
    return x ** 2 if x % 2 == 0 else -x

arr = np.array([1, 2, 3, 4])
processed = np.vectorize(custom_func)(arr)


```


**‚úÖ Euclidean Length of a Vector**

ƒê·ªô d√†i c·ªßa vector ƒë∆∞·ª£c t√≠nh b·∫±ng chu·∫©n Euclidean (norm):

```python
v = np.array([3, 4])
length = np.linalg.norm(v)  # Output: 5.0

```

**‚úÖ Vector addition**

C·ªông t·ª´ng ph·∫ßn t·ª≠ t∆∞∆°ng ·ª©ng gi·ªØa 2 vector:
```python
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
result = u + v  # array([5, 7, 9])

```

**‚úÖ Hadamard Product (Element-wise Multiplication)**

T√≠ch t·ª´ng ph·∫ßn t·ª≠ t∆∞∆°ng ·ª©ng gi·ªØa hai vector:

```python
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
result = u * v  # array([4, 10, 18])

```

**‚úÖ Dot Product (T√≠ch v√¥ h∆∞·ªõng)**
T√≠ch v√¥ h∆∞·ªõng (dot product) gi·ªØa hai vector:

```
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
dot = np.dot(u, v)  # 1*4 + 2*5 + 3*6 = 32
```


**‚úÖ Array Multiplication (Matrix Multiplication)**

Ph√©p nh√¢n ma tr·∫≠n (d√πng @ ho·∫∑c np.matmul):

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[2, 0], [1, 2]])

result = A @ B
# Ho·∫∑c: result = np.matmul(A, B)
# 
# K·∫øt qu·∫£: 
# A @ B = [[1√ó2 + 2√ó1, 1√ó0 + 2√ó2],
#         [3√ó2 + 4√ó1, 3√ó0 + 4√ó2]]
#       = [[2 + 2, 0 + 4],
#         [6 + 4, 0 + 8]]
#       = [[4, 4],
#         [10, 8]]


```

> üìå L∆∞u √Ω:
> 
> `*` l√† nh√¢n t·ª´ng ph·∫ßn t·ª≠ (Hadamard)
> 
> `@` l√† nh√¢n ma tr·∫≠n ƒë√∫ng chu·∫©n tuy·∫øn t√≠nh.
>
> N·∫øu kh√¥ng ƒë·ªÉ √Ω s·∫Ω d·ªÖ nh·∫ßm l·∫´n, cho n√™n c·∫ßn ƒë·ªÉ √Ω s·ª≠ d·ª•ng ƒë√∫ng ph√©p to√°n gi√∫p tr√°nh l·ªói khi l√†m vi·ªác v·ªõi d·ªØ li·ªáu ƒëa chi·ªÅu.

## 2.2 Bi·ªÉu di·ªÖn d·ªØ li·ªác d·∫°ng vector 2D/3D v·ªõi Numpy


# 3. ·ª®ng d·ª•ng 

# 4. Th·∫£o lu·∫≠n v√† m·ªü r·ªông 

# 5. K·∫øt lu·∫≠n

# 6. T√†i li·ªáu tham kh·∫£o
