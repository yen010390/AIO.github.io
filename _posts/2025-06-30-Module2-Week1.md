---
title: 'Module 02 - Week 01 -  N·ªôi dung'
excerpt: "ƒê·∫°i s·ªë tuy·∫øn t√≠nh c∆° b·∫£n v√† Numpy"
date: 2025-06-05
tags:
  - numpy
---
**T√°c gi·∫£**: Nguy·ªÖn Tu·∫•n Anh - ƒêo√†n T·∫•n H∆∞ng - H·ªì Th·ªã Ng·ªçc Huy·ªÅn - Tr·∫ßn Th·ªã M·ªπ T√∫ - ƒê·∫∑ng Th·ªã Ho√†ng Y·∫øn

**Nh√≥m**: MIX002 - AIO 2025

**M·ª•c l·ª•c** 
- [1. T√≥m t·∫Øt n·ªôi dung](#1-t√≥m-t·∫Øt-n·ªôi-dung)
- [2. C∆° s·ªü l√Ω thuy·∫øt](#2-c∆°-s·ªü-l√Ω-thuy·∫øt)
  - [2.1 Numpy - c∆° b·∫£n](#21-numpy---c∆°-b·∫£n)
    - [2.1.1 Numpy l√† g√¨](#211-numpy-l√†-g√¨)
    - [2.1.2 So s√°nh List v√† NumPy Array](#212-so-s√°nh-list-v√†-numpy-array)
    - [2.1.3 M·ªôt s·ªë k·ªπ thu·∫≠t n√¢ng cao v·ªõi Numpy](#213-m·ªôt-s·ªë-k·ªπ-thu·∫≠t-n√¢ng-cao-v·ªõi-numpy)
    - [2.1.4 M·ªôt s·ªë k·ªπ thu·∫≠t l·∫≠p tr√¨nh ph·ªï bi·∫øn v·ªõi NumPy](#214-m·ªôt-s·ªë-k·ªπ-thu·∫≠t-l·∫≠p-tr√¨nh-ph·ªï-bi·∫øn-v·ªõi-numpy)
  - [2.2 Bi·ªÉu di·ªÖn d·ªØ li·ªác d·∫°ng vector 2D/3D v·ªõi Numpy](#22-bi·ªÉu-di·ªÖn-d·ªØ-li·ªác-d·∫°ng-vector-2d3d-v·ªõi-numpy)
    - [2.2.1 Bi·ªÉu di·ªÖn m·∫£ng ƒëa chi·ªÅu](#221-bi·ªÉu-di·ªÖn-m·∫£ng-ƒëa-chi·ªÅu)
    - [2.2.2 M·ªôt s·ªë h√†m numpy ph·ªï bi·∫øn](#222-m·ªôt-s·ªë-h√†m-numpy-ph·ªï-bi·∫øn)
    - [2.2.2 M·ªôt s·ªë k·ªπ thu·∫≠t ph·ªï bi·∫øn v·ªõi array indexing](#222-m·ªôt-s·ªë-k·ªπ-thu·∫≠t-ph·ªï-bi·∫øn-v·ªõi-array-indexing)
    - [2.2.3 M·ªôt s·ªë operations v·ªõi array](#223-m·ªôt-s·ªë-operations-v·ªõi-array)
  - [2.3 Gi·ªõi thi·ªáu x·ª≠ l√Ω ·∫£nh v·ªõi OpenCV v√† NumPy](#23-gi·ªõi-thi·ªáu-x·ª≠-l√Ω-·∫£nh-v·ªõi-opencv-v√†-numpy)
    - [2.3.1 C∆° b·∫£n](#231-c∆°-b·∫£n)
    - [2.3.2 Brightness Changes ‚Äì Thay ƒë·ªïi ƒë·ªô s√°ng ·∫£nh](#232-brightness-changes--thay-ƒë·ªïi-ƒë·ªô-s√°ng-·∫£nh)
- [3. ·ª®ng d·ª•ng](#3-·ª©ng-d·ª•ng)
- [4. Th·∫£o lu·∫≠n v√† m·ªü r·ªông](#4-th·∫£o-lu·∫≠n-v√†-m·ªü-r·ªông)
- [5. K·∫øt lu·∫≠n](#5-k·∫øt-lu·∫≠n)
- [6. T√†i li·ªáu tham kh·∫£o](#6-t√†i-li·ªáu-tham-kh·∫£o)


# 1. T√≥m t·∫Øt n·ªôi dung

# 2. C∆° s·ªü l√Ω thuy·∫øt
## 2.1 Numpy - c∆° b·∫£n
### 2.1.1 Numpy l√† g√¨

**NumPy** (vi·∫øt t·∫Øt c·ªßa *Numerical Python*) l√† m·ªôt th∆∞ vi·ªán m√£ ngu·ªìn m·ªü trong Python, chuy√™n d√πng ƒë·ªÉ:

- L√†m vi·ªác v·ªõi **m·∫£ng nhi·ªÅu chi·ªÅu**.
- Th·ª±c hi·ªán c√°c ph√©p **t√≠nh to√°n s·ªë h·ªçc hi·ªáu nƒÉng cao**.
- H·ªó tr·ª£ c√°c thao t√°c to√°n h·ªçc, th·ªëng k√™, ƒë·∫°i s·ªë tuy·∫øn t√≠nh, x·ª≠ l√Ω t√≠n hi·ªáu, v.v.

> üîß NumPy l√† n·ªÅn t·∫£ng c·ªët l√µi cho c√°c th∆∞ vi·ªán l·ªõn nh∆∞ **Pandas, Scikit-learn, TensorFlow, PyTorch**,.. cho n√™n vi·ªác hi·ªÉu v√† v√† s·ª≠ d·ª•ng thu·∫ßn th·ª•c numpy l√† m·ªôt y·∫øu t·ªë kh√¥ng th·ªÉ thi·∫øu ƒë·ªÉ ƒë·ªçc hi·ªÉu v√† l·∫≠p tr√¨nh trong c√°c ·ª©ng d·ª•ng v√† m√¥ m√¨nh h·ªçc m√°y. 

### 2.1.2 So s√°nh List v√† NumPy Array
Trong Python, ki·ªÉu d·ªØ li·ªáu List v√† NumPy Array ƒë·ªÅu c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ v√† truy xu·∫•t d·ªØ li·ªáu d·∫°ng m·∫£ng.
Tuy nhi√™n, hai ki·ªÉu d·ªØ li·ªáu n√†y ph·ª•c v·ª• v√† ƒë∆∞·ª£c t·ªëi ∆∞u cho nh·ªØng m·ª•c ƒë√≠ch kh√°c nhau:
- **List**: Cho ph√©p ch·ª©a nhi·ªÅu ki·ªÉu d·ªØ li·ªáu kh√°c nhau (kh√¥ng ƒë·ªìng nh·∫•t) nh∆∞ chu·ªói, s·ªë nguy√™n, s·ªë th·ª±c, boolean, ho·∫∑c danh s√°ch l·ªìng nhau. ƒê√¢y l√† ki·ªÉu d·ªØ li·ªáu linh ho·∫°t trong Python, nh∆∞ng ch·ªâ h·ªó tr·ª£ m·ªôt chi·ªÅu truy c·∫≠p (m·ªôt ch·ªâ s·ªë). Ngo√†i ra, List kh√¥ng ƒë∆∞·ª£c t·ªëi ∆∞u cho c√°c ph√©p t√≠nh s·ªë h·ªçc ho·∫∑c x·ª≠ l√Ω d·ªØ li·ªáu hi·ªáu nƒÉng cao.
- **NumPy Array:** L√† t·ªïng qu√°t h√≥a c·ªßa vector trong to√°n h·ªçc. Array ho·∫°t ƒë·ªông hi·ªáu qu·∫£ trong vi·ªác bi·ªÉu di·ªÖn d·ªØ li·ªáu nhi·ªÅu chi·ªÅu th√¥ng qua ch·ªâ s·ªë nhi·ªÅu chi·ªÅu nh∆∞ A[i, j] (2D), B[i, j, k] (3D),... ƒê√¢y l√† ki·ªÉu d·ªØ li·ªáu ƒë·ªìng nh·∫•t ‚Äì t·∫•t c·∫£ ph·∫ßn t·ª≠ ph·∫£i c√πng ki·ªÉu ‚Äì v√† ƒë∆∞·ª£c t·ªëi ∆∞u cho t√≠nh to√°n s·ªë h·ªçc cho n√™n r·∫•t ph√π h·ª£p v·ªõi vi·ªác t√≠nh to√°n trong  khoa h·ªçc d·ªØ li·ªáu, v√† c√°c ·ª©ng d·ª•ng AI/ML.

Ta c√≥ th·ªÉ t·ªïng h·ª£p l·∫°i c√°c ƒëi·ªÉm kh√°c bi·ªát ch√≠nh gi·ªØa list v√† Numpy Array nh∆∞ sau: 

| Ti√™u ch√≠                          | Python List                                           | NumPy Array                                                           |
| --------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------- |
| **T√≠nh ƒë·ªìng nh·∫•t (ki·ªÉu d·ªØ li·ªáu)** | C√≥ th·ªÉ ch·ª©a **nhi·ªÅu ki·ªÉu d·ªØ li·ªáu** kh√°c nhau          | Ch·ªâ ch·ª©a **m·ªôt ki·ªÉu d·ªØ li·ªáu duy nh·∫•t** (ƒë·ªìng nh·∫•t)                    |
| **K√≠ch th∆∞·ªõc ƒë·ªông**               | C√≥ th·ªÉ thay ƒë·ªïi linh ho·∫°t (th√™m, x√≥a ph·∫ßn t·ª≠)         | C√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh sau khi t·∫°o (mu·ªën thay ƒë·ªïi c·∫ßn t·∫°o array m·ªõi)   |
| **ƒêa chi·ªÅu (multi-dimensional)**  | H·∫°n ch·∫ø ‚Äì c·∫ßn s·ª≠ d·ª•ng nested list                     | H·ªó tr·ª£ m·∫°nh m·∫Ω m·∫£ng nhi·ªÅu chi·ªÅu (2D, 3D, ...)                         |
| **Hi·ªáu su·∫•t t√≠nh to√°n**           | Ch·∫≠m h∆°n, kh√¥ng t·ªëi ∆∞u cho t√≠nh to√°n s·ªë l∆∞·ª£ng l·ªõn     | R·∫•t nhanh v√† hi·ªáu qu·∫£ nh·ªù s·ª≠ d·ª•ng C-level backend v√† vectorization    |
| **B·ªô nh·ªõ (Memory)**               | Kh√¥ng l∆∞u tr·ªØ li√™n t·ª•c trong b·ªô nh·ªõ                   | D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ **li√™n ti·∫øp** trong b·ªô nh·ªõ ‚Üí truy xu·∫•t nhanh h∆°n |
| **·ª®ng d·ª•ng ƒëi·ªÉn h√¨nh**            | L∆∞u tr·ªØ d·ªØ li·ªáu h·ªón h·ª£p, logic x·ª≠ l√Ω chung            | Ph√¢n t√≠ch d·ªØ li·ªáu s·ªë, AI/ML, x·ª≠ l√Ω ·∫£nh, to√°n h·ªçc t√≠nh to√°n cao c·∫•p    |
| **Th∆∞ vi·ªán h·ªó tr·ª£**               | Kh√¥ng c·∫ßn import                                      | C·∫ßn `import numpy as np`                                              |
| **C√°c ph√©p to√°n s·ªë h·ªçc**          | Kh√¥ng h·ªó tr·ª£ tr·ª±c ti·∫øp: ph·∫£i vi·∫øt v√≤ng l·∫∑p            | H·ªó tr·ª£ s·∫µn: `a + b`, `a * b`, `np.dot(a, b)`, `np.sum(a)`, ...        |
| **H·∫°n ch·∫ø ch√≠nh**                 | Kh√¥ng t·ªëi ∆∞u cho t√≠nh to√°n l·ªõn; kh√¥ng c√≥ broadcasting | Kh√¥ng linh ho·∫°t ki·ªÉu d·ªØ li·ªáu; c·∫ßn chuy·ªÉn ƒë·ªïi khi c·∫ßn ki·ªÉu h·ªón h·ª£p     |

<br>
C√°c API l·∫≠p tr√¨nh ch√≠nh khi l√†m vi·ªác gi·ªØa List v√† Numpy Array ƒë∆∞·ª£c ƒë·ªëi chi·∫øu nh∆∞ sau: 


| T√°c v·ª•                                | Python List                               | NumPy Array                                                                   |
| ------------------------------------- | ----------------------------------------- | ----------------------------------------------------------------------------- |
| **T·∫°o m·∫£ng**                          | `l = [1, 2, 3]`                           | `a = np.array([1, 2, 3])`                                                     |
| **Indexing & Slicing**                | `l[1]`, `l[1:3]`, `l[::-1]`               | `a[1]`, `a[1:3]`, `a[::-1]`                                                   |
| **Th√™m ph·∫ßn t·ª≠**                      | `l.append(4)`, `l.insert(0, 0)`           | `np.append(a, 4)`, `np.insert(a, 0, 0)`                                       |
| **C·∫≠p nh·∫≠t ph·∫ßn t·ª≠**                  | `l[1] = 10`                               | `a[1] = 10`                                                                   |
| **To√°n t·ª≠ `+`, `*`**                  | `l + l2` ‚Üí n·ªëi list<br>`l * 2` ‚Üí l·∫∑p l·∫°i  | `a + a2` ‚Üí c·ªông ph·∫ßn t·ª≠<br>`a * 2` ‚Üí nh√¢n ph·∫ßn t·ª≠                             |
| **S·∫Øp x·∫øp**                           | `l.sort()`, <br> `l.sort(reverse=True)`   | Kh√¥ng c√≥ x·∫Øp x·∫øp gi·∫£m d·∫ßn <br> `a.sort()`, <br>`a[::-1]` (ƒë·∫£o ng∆∞·ª£c sau sort) |
| **X√≥a ph·∫ßn t·ª≠**                       | `l.pop(1)`, `del l[1]`, `l.remove(3)`     | `np.delete(a, 1)`<br>`np.delete(a, np.where(a==3))`                           |
| **T√¨m ch·ªâ s·ªë (`index`)**              | `l.index(3)`                              | `np.where(a == 3)[0][0]`                                                      |
| **ƒê·∫øm v√† sao ch√©p (`count`, `copy`)** | `l.count(3)`, `l.copy()`                  | `np.sum(a == 3)`, `a.copy()`                                                  |
| **`len()`, `min()`, `max()`**         | `len(l)`, `min(l)`, `max(l)`              | `len(a)`, `np.min(a)`, `np.max(a)`                                            |
| **K√≠ch th∆∞·ªõc (`shape`)**              | Kh√¥ng c√≥ thu·ªôc t√≠nh `shape`               | `a.shape` ‚Üí cho bi·∫øt s·ªë chi·ªÅu v√† k√≠ch th∆∞·ªõc                                   |
| **T·ªïng (`sum`)**                      | `sum(l)`                                  | `np.sum(a)`                                                                   |
| **Zip `zip()`**                       | Kh√¥ng h·ªó tr·ª£ zip <br> `list(zip(l1, l2))` | `np.stack([a1, a2], axis=1)` / `np.column_stack()`                            |
| **Enumerate `enumerate()`**           | `enumerate(l)`                            | `np.ndenumerate(a)`                                                           |
| **D·ªØ li·ªáu 2D**                        | `[[1, 2], [3, 4]]`                        | `np.array([[1, 2], [3, 4]])`                                                  |


<br>

> üß† **T·ªïng k·∫øt**:  
> - **List** th√≠ch h·ª£p cho d·ªØ li·ªáu h·ªón h·ª£p ho·∫∑c logic linh ho·∫°t.  
> - **NumPy Array** ƒë∆∞·ª£c thi·∫øt k·∫ø chuy√™n bi·ªát cho hi·ªáu nƒÉng cao v√† x·ª≠ l√Ω d·ªØ li·ªáu s·ªë v·ªõi k√≠ch th∆∞·ªõc l·ªõn/multidimensional ‚Äî r·∫•t ph√π h·ª£p trong khoa h·ªçc d·ªØ li·ªáu v√† AI.

### 2.1.3 M·ªôt s·ªë k·ªπ thu·∫≠t n√¢ng cao v·ªõi Numpy
**‚úÖ Integer Array Indexing**: B·∫°n c√≥ th·ªÉ ch·ªçn nhi·ªÅu ph·∫ßn t·ª≠ theo ch·ªâ s·ªë c·ª• th·ªÉ:

```python
a = np.array([10, 20, 30, 40, 50])
idx = [1, 3]
result = a[idx]  # [20, 40]
```

**‚úÖ Boolean Array Indexing**: L·ªçc ph·∫ßn t·ª≠ d·ª±a tr√™n ƒëi·ªÅu ki·ªán
```python
a = np.array([1, 2, 3, 4, 5])
mask = a > 3
filtered = a[mask]  # [4, 5]
```
**‚úÖ Array Manipulation - Reshape**: Thay ƒë·ªïi shape m·∫£ng m√† kh√¥ng thay ƒë·ªïi d·ªØ li·ªáu
```python
a = np.array([1, 2, 3, 4, 5, 6])
a_reshaped = a.reshape((2, 3))
```
**‚úÖ Array Manipulation - Flatten**: Chuy·ªÉn array nhi·ªÅu chi·ªÅu th√†nh 1 chi·ªÅu
```python
a = np.array([[1, 2], [3, 4]])
flat = a.flatten()  # [1 2 3 4]
```
**‚úÖ  Concatenate & Stack**: G·ªôp m·∫£ng
```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])

np.vstack((a, b))  # G·ªôp theo chi·ªÅu d·ªçc
np.hstack((a, b.T))  # G·ªôp theo chi·ªÅu ngang
```
**‚úÖ Broadcasting**: cho ph√©p b·∫°n th·ª±c hi·ªán ph√©p to√°n tr√™n c√°c array c√≥ shape kh√¥ng gi·ªëng nhau m√† kh√¥ng c·∫ßn v√≤ng l·∫∑p
```python
a = np.array([[1], [2], [3]])  # shape (3,1)
b = np.array([10, 20, 30])     # shape (3,)
result = a + b  # shape (3,3)

```
> L∆∞u √Ω: NumPy s·∫Ω m·ªü r·ªông m·∫£ng nh·ªè h∆°n theo chi·ªÅu c·∫ßn thi·∫øt
>

**‚úÖ Vectorization** t·ªëi ∆∞u hi·ªáu nƒÉng nhi·ªÅu l·∫ßn so v·ªõi v√≤ng l·∫∑p truy·ªÅn th·ªëng

üò≠ C√°ch kh√¥ng t·ªëi ∆∞u

```python
result = []
for x in a:
    result.append(x ** 2)

```

üòä C√°ch t·ªëi ∆∞u b·∫±ng Vectorization

```python
result = a ** 2
```

üòä B·∫°n c√≥ th·ªÉ d√πng Vectorization v·ªõi np.sin, np.exp, np.log tr√™n to√†n b·ªô array:
```python
x = np.linspace(0, 2 * np.pi, 1_000_000)
y = np.sin(x) * np.exp(-x)
```

**Sau ƒë√¢y l√† m·ªôt s·ªë benchmark** khi √°p d·ª•ng Vectorization  gi√∫p tƒÉng t·ªëc ƒë·ªô l√™n g·∫•p nhi·ªÅu l·∫ßn. 

**‚è±Ô∏è ƒê√°nh gi√° 01**: `ùëì(ùë•) = sinùë•*ùëí^‚àíùë•`, khi ch·∫°y tr√™n Google colab, s·ª≠ d·ª•ng Vectorization tƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω l√™n 12.42 l·∫ßn

![Vectorization Benchmark 01](/AIO.github.io/images/m02/w01/numpy-vectorization-benchmark01-sinxe.png "Vectorization Benchmark")

**‚è±Ô∏è ƒê√°nh gi√° 02**: t·ªëc ƒë·ªô x·ª≠ l√Ω nhanh h∆°n 41 l·∫ßn.

![Vectorization Benchmark 01](/AIO.github.io/images/m02/w01/numpy-vectorization-benchmark02.png "Vectorization Benchmark")

### 2.1.4 M·ªôt s·ªë k·ªπ thu·∫≠t l·∫≠p tr√¨nh ph·ªï bi·∫øn v·ªõi NumPy
**‚úÖ Stack two arrays vertically**

G·ªôp nhi·ªÅu m·∫£ng theo chi·ªÅu d·ªçc (tƒÉng s·ªë d√≤ng). C·∫ßn ƒë·∫£m b·∫£o s·ªë c·ªôt gi·ªëng nhau.

```python
import numpy as np

a = np.array([[0, 1, 2], [3, 4, 5]])
b = np.array([[6, 7, 8]])

result = np.vstack((a, b))
```
**‚úÖ Stack two arrays horizontally**

G·ªôp nhi·ªÅu m·∫£ng theo chi·ªÅu ngang (tƒÉng s·ªë c·ªôt). C·∫ßn ƒë·∫£m b·∫£o s·ªë d√≤ng gi·ªëng nhau.

```python
a = np.array([[0, 1, 2], [3, 4, 5]])
b = np.array([[6], [7]])

result = np.hstack((a, b))

```

**‚úÖ Take all elements satisfying with a given predefined condition**

L·ªçc d·ªØ li·ªáu b·∫±ng ƒëi·ªÅu ki·ªán logic (boolean indexing):
```python
arr = np.array([1, 8, 2, 5, 4, 6, 0, 7, 9, 3])
filtered = arr[arr < 7]  # array([1, 2, 5, 4, 6, 0, 3])
```

**‚úÖ Apply a user-defined function for array**

B·∫°n c√≥ th·ªÉ √°p d·ª•ng h√†m t·ª± ƒë·ªãnh nghƒ©a b·∫±ng np.vectorize ho·∫∑c np.where.

```python
def custom_func(x):
    return x ** 2 if x % 2 == 0 else -x

arr = np.array([1, 2, 3, 4])
processed = np.vectorize(custom_func)(arr)


```


**‚úÖ Euclidean Length of a Vector**

ƒê·ªô d√†i c·ªßa vector ƒë∆∞·ª£c t√≠nh b·∫±ng chu·∫©n Euclidean (norm):

```python
v = np.array([3, 4])
length = np.linalg.norm(v)  # Output: 5.0

```

**‚úÖ Vector addition**

C·ªông t·ª´ng ph·∫ßn t·ª≠ t∆∞∆°ng ·ª©ng gi·ªØa 2 vector:
```python
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
result = u + v  # array([5, 7, 9])

```

**‚úÖ Hadamard Product (Element-wise Multiplication)**

T√≠ch t·ª´ng ph·∫ßn t·ª≠ t∆∞∆°ng ·ª©ng gi·ªØa hai vector:

```python
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
result = u * v  # array([4, 10, 18])

```

**‚úÖ Dot Product (T√≠ch v√¥ h∆∞·ªõng)**
T√≠ch v√¥ h∆∞·ªõng (dot product) gi·ªØa hai vector:

```
u = np.array([1, 2, 3])
v = np.array([4, 5, 6])
dot = np.dot(u, v)  # 1*4 + 2*5 + 3*6 = 32
```


**‚úÖ Array Multiplication (Matrix Multiplication)**

Ph√©p nh√¢n ma tr·∫≠n (d√πng @ ho·∫∑c np.matmul):

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[2, 0], [1, 2]])

result = A @ B
# Ho·∫∑c: result = np.matmul(A, B)
# 
# K·∫øt qu·∫£: 
# A @ B = [[1√ó2 + 2√ó1, 1√ó0 + 2√ó2],
#         [3√ó2 + 4√ó1, 3√ó0 + 4√ó2]]
#       = [[2 + 2, 0 + 4],
#         [6 + 4, 0 + 8]]
#       = [[4, 4],
#         [10, 8]]


```

> üìå L∆∞u √Ω:
> 
> `*` l√† nh√¢n t·ª´ng ph·∫ßn t·ª≠ (Hadamard)
> 
> `@` l√† nh√¢n ma tr·∫≠n ƒë√∫ng chu·∫©n tuy·∫øn t√≠nh.
>
> N·∫øu kh√¥ng ƒë·ªÉ √Ω s·∫Ω d·ªÖ nh·∫ßm l·∫´n, cho n√™n c·∫ßn ƒë·ªÉ √Ω s·ª≠ d·ª•ng ƒë√∫ng ph√©p to√°n gi√∫p tr√°nh l·ªói khi l√†m vi·ªác v·ªõi d·ªØ li·ªáu ƒëa chi·ªÅu.

## 2.2 Bi·ªÉu di·ªÖn d·ªØ li·ªác d·∫°ng vector 2D/3D v·ªõi Numpy
### 2.2.1 Bi·ªÉu di·ªÖn m·∫£ng ƒëa chi·ªÅu

**B·∫£ng ghi nh·ªõ:**

| S·ªë chi·ªÅu | T√™n g·ªçi | M√¥ t·∫£                 | ·ª®ng d·ª•ng ƒëi·ªÉn h√¨nh trong ML               |
| -------- | ------- | --------------------- | ----------------------------------------- |
| 1D       | Vector  | Danh s√°ch c√°c gi√° tr·ªã | Feature vector, ƒë·∫ßu v√†o m√¥ h√¨nh h·ªçc m√°y   |
| 2D       | Matrix  | H√†ng v√† c·ªôt           | B·∫£ng d·ªØ li·ªáu, ·∫£nh grayscale               |
| 3D       | Tensor  | T·∫≠p h·ª£p nhi·ªÅu ma tr·∫≠n | ·∫¢nh m√†u RGB, d·ªØ li·ªáu th·ªùi gian, batch ·∫£nh |


**‚úÖ M·∫£ng 1D (vector)**

M·∫£ng 1 chi·ªÅu l√† danh s√°ch c√°c ph·∫ßn t·ª≠, t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vector.

```python
import numpy as np

arr_1d = np.array([1, 2, 3])
print(arr_1d.shape)  # Output: (3,)
```

> Trong ƒë√≥: `shape=(3,)` cho bi·∫øt ƒë√¢y l√† m·∫£ng c√≥ 3 ph·∫ßn t·ª≠, ch·ªâ c√≥ 1 chi·ªÅu.

**‚úÖ M·∫£ng 2D (matrix)**

M·∫£ng 2 chi·ªÅu th∆∞·ªùng bi·ªÉu di·ªÖn d·∫°ng ma tr·∫≠n (table) v·ªõi h√†ng v√† c·ªôt.

```python
arr_2d = np.array([[1, 2], [3, 4], [5, 6]])
print(arr_2d.shape)  # Output: (3, 2)
```
> Trong ƒë√≥: `shape=(3,2)` nghƒ©a l√† c√≥ 3 h√†ng, 2 c·ªôt.
>


**‚úÖ M·∫£ng 3D (tensor)**

M·∫£ng 3 chi·ªÅu l√† t·∫≠p h·ª£p c√°c ma tr·∫≠n, th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ bi·ªÉu di·ªÖn ·∫£nh m√†u ho·∫∑c d·ªØ li·ªáu th·ªùi gian.

```python
arr_3d = np.array([
    [[1, 2], [3, 4]],
    [[5, 6], [7, 8]],
    [[9, 10], [11, 12]]
])
print(arr_3d.shape)  # Output: (3, 2, 2)

```

> Trong ƒë√≥: `shape=(3,2,2)` nghƒ©a l√† c√≥ 3 ma tr·∫≠n, m·ªói ma tr·∫≠n c√≥ 2 h√†ng v√† 2 c·ªôt.

### 2.2.2 M·ªôt s·ªë h√†m numpy ph·ªï bi·∫øn

**B·∫£ng ghi nh·ªõ:**

| H√†m                | M√¥ t·∫£ ng·∫Øn g·ªçn                                    | Nh√≥m b√†i to√°n ·ª©ng d·ª•ng                                   |
| ------------------ | ------------------------------------------------- | -------------------------------------------------------- |
| `np.zeros()`       | T·∫°o m·∫£ng v·ªõi to√†n b·ªô ph·∫ßn t·ª≠ l√† 0                 | Kh·ªüi t·∫°o d·ªØ li·ªáu, ma tr·∫≠n tr·ªçng s·ªë ban ƒë·∫ßu (ML/DL)       |
| `np.ones()`        | T·∫°o m·∫£ng v·ªõi to√†n b·ªô ph·∫ßn t·ª≠ l√† 1                 | Bias vector, c·∫•u h√¨nh baseline cho th·ª≠ nghi·ªám            |
| `np.arange()`      | T·∫°o d√£y s·ªë c√°ch ƒë·ªÅu                               | Sinh ch·ªâ s·ªë, x·ª≠ l√Ω chu·ªói th·ªùi gian, t·∫°o d·∫£i gi√° tr·ªã      |
| `np.reshape()`     | Thay ƒë·ªïi h√¨nh d·∫°ng m·∫£ng m√† kh√¥ng thay ƒë·ªïi d·ªØ li·ªáu | Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o m√¥ h√¨nh, x·ª≠ l√Ω ·∫£nh             |
| `np.repeat()`      | L·∫∑p l·∫°i ph·∫ßn t·ª≠ ho·∫∑c theo chi·ªÅu c·ª• th·ªÉ            | D·ªØ li·ªáu h√¨nh ·∫£nh (upscale), nh√¢n b·∫£n ƒë·∫∑c tr∆∞ng           |
| `np.flatten()`     | Chuy·ªÉn m·∫£ng nhi·ªÅu chi·ªÅu th√†nh 1 chi·ªÅu             | Vector h√≥a ·∫£nh, chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o neural network |
| `np.concatenate()` | N·ªëi c√°c m·∫£ng l·∫°i v·ªõi nhau theo h√†ng ho·∫∑c c·ªôt      | Gh√©p batch, k·∫øt h·ª£p ƒë·∫∑c tr∆∞ng (feature fusion)           |
| `np.clip()`        | Gi·ªõi h·∫°n gi√° tr·ªã trong kho·∫£ng x√°c ƒë·ªãnh            | X·ª≠ l√Ω ·∫£nh (gi·ªõi h·∫°n pixel), x·ª≠ l√Ω ngo·∫°i l·ªá (outlier)     |

**‚úÖ H√†m np.zeros()**

T·∫°o m·ªôt m·∫£ng to√†n s·ªë 0.

```python
import numpy as np

arr = np.zeros((2, 3))
print(arr)

# Output:
# [[0. 0. 0.]
# [0. 0. 0.]]

```

**‚úÖ H√†m np.ones()**

T·∫°o m·ªôt m·∫£ng to√†n s·ªë 1.

```python
arr = np.ones((3, 2))
print(arr)

# Output: 
# [[1. 1.]
# [1. 1.]
# [1. 1.]]
```

**‚úÖ H√†m np.arange()**

T·∫°o m·ªôt m·∫£ng 1D v·ªõi gi√° tr·ªã tƒÉng ƒë·ªÅu.

```python
arr = np.arange(0, 10, 2)
print(arr)

# Output: 
# [0 2 4 6 8]

```

**‚úÖ H√†m np.reshape()**

Thay ƒë·ªïi k√≠ch th∆∞·ªõc m·∫£ng m√† kh√¥ng thay ƒë·ªïi d·ªØ li·ªáu.
```python
arr = np.arange(6)
arr_reshaped = arr.reshape((2, 3))
print(arr_reshaped)

# Output: 
# [[0 1 2]
# [3 4 5]]

```
**‚úÖ H√†m np.repeat()**

L·∫∑p l·∫°i t·ª´ng ph·∫ßn t·ª≠ ho·∫∑c theo chi·ªÅu c·ª• th·ªÉ.
```python
arr = np.array([[1, 2], [3, 4]])
# Repeat t·ª´ng ph·∫ßn t·ª≠ 2 l·∫ßn
print(np.repeat(arr, 2))
# Repeat theo axis=0 (l·∫∑p d√≤ng)
print(np.repeat(arr, 2, axis=0))
# Repeat theo axis=1 (l·∫∑p c·ªôt)
print(np.repeat(arr, 2, axis=1))

# Output: 
# [1 1 2 2 3 3 4 4]         # kh√¥ng c√≥ axis
#
# [[1 2]                    # axis=0
#  [1 2]
#  [3 4]
#  [3 4]]                   
#
# [[1 1 2 2]                # axis=1
#  [3 3 4 4]]               

```

**‚úÖ H√†m np.flatten()**

Chuy·ªÉn m·∫£ng nhi·ªÅu chi·ªÅu th√†nh m·∫£ng 1 chi·ªÅu (vector).

```python
arr = np.array([[1, 2], [3, 4]])
flat = arr.flatten()
print(flat)

# Output: 
# [1 2 3 4]
```

**‚úÖ H√†m np.concatenate()**

N·ªëi nhi·ªÅu m·∫£ng l·∫°i v·ªõi nhau theo m·ªôt tr·ª•c nh·∫•t ƒë·ªãnh.

```python
a = np.array([[1, 2]])
b = np.array([[3, 4]])
concat_0 = np.concatenate((a, b), axis=0)  # N·ªëi theo h√†ng
concat_1 = np.concatenate((a.T, b.T), axis=1)  # N·ªëi theo c·ªôt
print(concat_0)
print(concat_1)

# [[1 2]      # axis=0
#  [3 4]]     
# 
# [[1 3]      # axis=1
#  [2 4]]     
```

**‚úÖ H√†m np.clip()**

Gi·ªõi h·∫°n gi√° tr·ªã trong m·∫£ng trong m·ªôt kho·∫£ng cho tr∆∞·ªõc.
```python
arr = np.array([10, 200, 300])
clipped = np.clip(arr, 0, 255)
print(clipped)

# Output: 
# [10 200 255]

```


### 2.2.2 M·ªôt s·ªë k·ªπ thu·∫≠t ph·ªï bi·∫øn v·ªõi array indexing

**B·∫£ng Ghi Nh·ªõ:**

| K·ªπ thu·∫≠t             | M√¥ t·∫£ ng·∫Øn g·ªçn                                                   | ·ª®ng d·ª•ng ƒëi·ªÉn h√¨nh trong ML                                   |
| -------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------- |
| `Slicing`            | C·∫Øt m·ªôt ph·∫ßn m·∫£ng theo tr·ª•c (`:` ho·∫∑c `[a:b]`)                   | L·∫•y batch d·ªØ li·ªáu, c·∫Øt v√πng ·∫£nh, t·∫°o t·∫≠p con                  |
| `Get a row`          | Truy xu·∫•t 1 h√†ng t·ª´ m·∫£ng 2D (`arr[i]` ho·∫∑c `arr[i:i+1]`)         | L·∫•y m·∫´u d·ªØ li·ªáu ƒë∆°n l·∫ª ƒë·ªÉ ki·ªÉm tra/so s√°nh                    |
| `Get a column`       | Truy xu·∫•t 1 c·ªôt t·ª´ m·∫£ng 2D (`arr[:, j]` ho·∫∑c `arr[:, j:j+1]`)    | Tr√≠ch xu·∫•t 1 feature ƒë·ªÉ tr·ª±c quan h√≥a ho·∫∑c chu·∫©n h√≥a ri√™ng    |
| `Lists as indices`   | Ch·ªâ ƒë·ªãnh index c·ª• th·ªÉ b·∫±ng danh s√°ch (`arr[[i1, i2], [j1, j2]]`) | L·∫•y m·∫´u kh√¥ng li√™n ti·∫øp, sampling c√≥ ki·ªÉm so√°t                |
| `Boolean as indices` | Truy xu·∫•t ph·∫ßn t·ª≠ th·ªèa ƒëi·ªÅu ki·ªán (`arr[arr > 0]`)                | L·ªçc d·ªØ li·ªáu theo ƒëi·ªÅu ki·ªán (v√≠ d·ª•: lo·∫°i b·ªè outlier, mask ·∫£nh) |

---
Ghi ch√∫: 
- C√°c k·ªπ thu·∫≠t n√†y r·∫•t ph·ªï bi·∫øn trong x·ª≠ l√Ω ·∫£nh, NLP, v√† ph√¢n t√≠ch d·ªØ li·ªáu (EDA).
- Boolean indexing ƒë·∫∑c bi·ªát hi·ªáu qu·∫£ khi c·∫ßn l·ªçc d·ªØ li·ªáu nhanh m√† kh√¥ng c·∫ßn v√≤ng l·∫∑p.

**‚úÖ Slicing**

D√πng ƒë·ªÉ l·∫•y m·ªôt ph·∫ßn c·ªßa m·∫£ng theo tr·ª•c nh·∫•t ƒë·ªãnh.

```python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr[0:2, 1:])  # l·∫•y 2 d√≤ng ƒë·∫ßu, t·ª´ c·ªôt th·ª© 2 tr·ªü ƒëi

# Output
# [[2 3]
# [5 6]]
```

> G·ª£i √Ω: C√∫ ph√°p `arr[start:stop, :]` t∆∞∆°ng t·ª± slicing trong list.

**‚úÖ Get a row**

L·∫•y m·ªôt h√†ng

```python
print(arr[1])      # d·∫°ng vector (shape: (3,))
print(arr[1:2])    # d·∫°ng ma tr·∫≠n (shape: (1, 3))

# Output: 
# [4 5 6]           # 1D vector
# [[4 5 6]]         # 2D matrix

```

**‚úÖ Get a column**

L·∫•y m·ªôt c·ªôt

```python
print(arr[:, 0])       # d·∫°ng vector (shape: (3,))
print(arr[:, 0:1])     # d·∫°ng ma tr·∫≠n (shape: (3, 1))

# Output: 
# [1 4 7]             # 1D vector
#
# [[1]                # 2D matrix
#  [4]
#  [7]]               
```

> G·ª£i √Ω:  D√πng `arr[:, j]` ƒë·ªÉ l·∫•y c·ªôt th·ª© j.

**‚úÖ Lists as indices**

D√πng ƒë·ªÉ truy xu·∫•t nhi·ªÅu ph·∫ßn t·ª≠ kh√¥ng li√™n ti·∫øp.
```python
arr = np.array([[10, 20], [30, 40], [50, 60]])
print(arr[[0, 2], [1, 0]])  # l·∫•y ph·∫ßn t·ª≠ (0,1) v√† (2,0)

# Output: 
# [20 50]

```

**‚úÖ Boolean as indices**
L·ªçc ra c√°c ph·∫ßn t·ª≠ th·ªèa ƒëi·ªÅu ki·ªán.

```python
arr = np.array([1, 3, 5, 2, 4])
mask = arr > 3
print(mask)
print(arr[mask])

# Output
# [False False  True False  True]
# [5 4]

```

### 2.2.3 M·ªôt s·ªë operations v·ªõi array

**B·∫£ng ghi nh·ªõ:** 

| Operation              | M√¥ t·∫£ ng·∫Øn g·ªçn                                            | ·ª®ng d·ª•ng ƒëi·ªÉn h√¨nh trong ML/DS                                                                                    |
| ---------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `np.sum()`             | T√≠nh t·ªïng to√†n b·ªô ho·∫∑c theo tr·ª•c c·ª• th·ªÉ                   | T√≠nh t·ªïng loss theo batch<br>T√≠nh t·ªïng x√°c su·∫•t (e.g. softmax)<br>T·ªïng pixel ·∫£nh (grayscale: m·∫£ng 2D)             |
| `np.mean()`            | T√≠nh gi√° tr·ªã trung b√¨nh to√†n m·∫£ng ho·∫∑c theo tr·ª•c          | T√≠nh mean feature cho m·ªói chi·ªÅu d·ªØ li·ªáu tabular<br>Feature scaling (mean normalization)<br>Trung b√¨nh ƒë·ªô s√°ng ·∫£nh |
| `np.max()`, `np.min()` | L·∫•y gi√° tr·ªã l·ªõn nh·∫•t / nh·ªè nh·∫•t trong m·∫£ng ho·∫∑c theo tr·ª•c | Max pooling trong CNN (`(batch, channels, height, width)`)<br>L·ªçc outlier<br>Chu·∫©n h√≥a min-max                    |
| `array * scalar`       | Broadcasting: nh√¢n t·ª´ng ph·∫ßn t·ª≠ v·ªõi m·ªôt gi√° tr·ªã           | Scale tr·ªçng s·ªë (`weight * alpha`)<br>TƒÉng/gi·∫£m ƒë·ªô s√°ng ·∫£nh RGB (m·∫£ng 3D)<br>TƒÉng c∆∞·ªùng d·ªØ li·ªáu (augmentation)     |
| `matrix + vector`      | Broadcasting: c·ªông t·ª´ng d√≤ng v·ªõi vector (theo chi·ªÅu axis) | Th√™m bias v√†o input layer<br>C·ªông embedding vector trong NLP<br>ƒêi·ªÅu ch·ªânh feature theo offset vector             |

---

üß† Ghi ch√∫:
- C√°c thao t√°c n√†y xu·∫•t hi·ªán th∆∞·ªùng xuy√™n trong pipeline c·ªßa c√°c b√†i to√°n:
  - **Computer Vision** (x·ª≠ l√Ω ·∫£nh, tƒÉng s√°ng, pooling)
  - **NLP** (x·ª≠ l√Ω embedding, c·ªông vector t·ª´ t·ª´ ƒëi·ªÉn)
  - **Tabular Data** (chu·∫©n h√≥a feature, x·ª≠ l√Ω input ƒë·∫ßu v√†o)
  - **Training loop** (t√≠nh loss, t·ªïng gradient)


**‚úÖ Summation**

T√≠nh t·ªïng to√†n m·∫£ng

```python
import numpy as np

arr = np.array([[1, 2], [3, 4]])
print(np.sum(arr))  # Output: 10
```

T·ªïng theo h√†ng (axis=1) ho·∫∑c theo c·ªôt (axis=0)

```python
print(np.sum(arr, axis=0))  # Output: [4 6]
print(np.sum(arr, axis=1))  # Output: [3 7]

```

**‚úÖ Mean**

T√≠nh gi√° tr·ªã trung b√¨nh (mean) c·ªßa t·∫•t c·∫£ ph·∫ßn t·ª≠ trong m·∫£ng ho·∫∑c theo m·ªôt tr·ª•c c·ª• th·ªÉ.

```python

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(np.mean(arr))           # Output: 3.5  (mean to√†n m·∫£ng)
print(np.mean(arr, axis=0))   # Output: [2.5 3.5 4.5] (mean theo c·ªôt)
print(np.mean(arr, axis=1))   # Output: [2. 5.]        (mean theo h√†ng)

```
**‚úÖ Max and min**

D√πng ƒë·ªÉ t√¨m ƒëi·ªÉm c·ª±c tr·ªã trong d·ªØ li·ªáu. 

To√†n m·∫£ng
```python
print(np.max(arr))  # Output: 4
print(np.min(arr))  # Output: 1

```

Theo tr·ª•c (axis)
```python
print(np.max(arr, axis=0))  # Output: [3 4]
print(np.min(arr, axis=1))  # Output: [1 3]
```

**‚úÖ Vector and a scalar**

Broadcasting v·ªõi s·ªë
```python
arr = np.array([[1, 2], [3, 4]])

# M·ªói ph·∫ßn t·ª≠ trong m·∫£ng ƒë∆∞·ª£c nh√¢n v·ªõi scalar 2. ƒê√¢y l√† v√≠ d·ª• ƒë∆°n gi·∫£n c·ªßa broadcasting.
print(arr * 2)

# Output:
# [[2 4]
#  [6 8]]

```
**‚úÖ Matrix and vector**

Numpy s·∫Ω t·ª± ƒë·ªông "broadcast" vector ƒë·ªÉ √°p d·ª•ng cho t·ª´ng d√≤ng c·ªßa ma tr·∫≠n. Vi·ªác n√†y r·∫•t h·ªØu √≠ch trong x·ª≠ l√Ω ·∫£nh, bi·ªÉu di·ªÖn d·ªØ li·ªáu th·ªùi gian, v√† m·∫°ng neural.

```python
matrix = np.array([[1, 2, 3],
                   [4, 5, 6]])
vector = np.array([1, 0, 1])

print(matrix + vector)

# Output:
# [[2 2 4]
#  [5 5 7]]

```

## 2.3 Gi·ªõi thi·ªáu x·ª≠ l√Ω ·∫£nh v·ªõi OpenCV v√† NumPy
### 2.3.1 C∆° b·∫£n

- **OpenCV** l√† th∆∞ vi·ªán m·∫°nh m·∫Ω ƒë·ªÉ x·ª≠ l√Ω ·∫£nh v√† video trong Python.
- **NumPy** h·ªó tr·ª£ thao t√°c nhanh v√† hi·ªáu qu·∫£ tr√™n ·∫£nh d∆∞·ªõi d·∫°ng m·∫£ng (array).
- K·∫øt h·ª£p OpenCV + NumPy ‚Üí x·ª≠ l√Ω ·∫£nh nhanh, thu·∫≠n ti·ªán cho AI v√† Machine Learning.


**Chuy·ªÉn ƒë·ªïi t·ª´ ·∫£nh v√† Numpy array**
| Lo·∫°i ·∫£nh      | Ki·ªÉu d·ªØ li·ªáu    | Shape (NumPy array) | Ghi ch√∫                                 |
| ------------- | --------------- | ------------------- | --------------------------------------- |
| ·∫¢nh grayscale | `uint8`, 0‚Äì255  | `(H, W)`            | M·ªói pixel l√† 1 s·ªë                       |
| ·∫¢nh m√†u RGB   | `uint8`, 0‚Äì255  | `(H, W, 3)`         | M·ªói pixel l√† `[R, G, B]`                |
| ·∫¢nh m√†u BGR   | OpenCV m·∫∑c ƒë·ªãnh | `(H, W, 3)`         | C·∫ßn chuy·ªÉn sang RGB khi d√πng matplotlib |

**ƒê·ªçc ·∫£nh b·∫±ng OpenCV**
```python
import cv2

img = cv2.imread('image.jpg')      # ƒê·ªçc ·∫£nh m√†u (BGR)
gray = cv2.imread('image.jpg', 0)  # ƒê·ªçc ·∫£nh x√°m (grayscale)
```

**Hi·ªán ·∫£nh b·∫±ng matplotlib**
```python
import matplotlib.pyplot as plt

# Chuy·ªÉn t·ª´ BGR ‚Üí RGB
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.imshow(img_rgb)
plt.axis('off')
plt.show()

```

**Thao t√°c ·∫£nh b·∫±ng NumPy - Thay ƒë·ªïi ƒë·ªô s√°ng**
```python
bright = img + 50
bright = np.clip(bright, 0, 255).astype(np.uint8)

```

**Thao t√°c ·∫£nh b·∫±ng NumPy - Gi·∫£m ƒë·ªô s√°ng**
```python
dark = img - 50
dark = np.clip(dark, 0, 255).astype(np.uint8)

```

**Thao t√°c ·∫£nh b·∫±ng NumPy - C·∫Øt ·∫£nh (cropping)**
```python
crop = img[50:200, 100:300]  # [y1:y2, x1:x2]

```
**Thao t√°c ·∫£nh b·∫±ng NumPy - ƒê·∫£o m√†u (invert)**
```python
inv = 255 - img
```
**M·ªôt s·ªë k·ªπ thu·∫≠t kh√°c**
| ·ª®ng d·ª•ng                     | K·ªπ thu·∫≠t li√™n quan                       |
| ---------------------------- | ---------------------------------------- |
| Ti·ªÅn x·ª≠ l√Ω ·∫£nh               | Resize, crop, normalize                  |
| Augmentation d·ªØ li·ªáu         | L·∫≠t, xoay, th√™m nhi·ªÖu (v·ªõi NumPy/OpenCV) |
| Chuy·ªÉn ·∫£nh ‚Üí input cho model | Chuy·ªÉn dtype, reshape, flatten           |
| Ph√¢n t√≠ch h√¨nh ·∫£nh           | L·ªçc v√πng s√°ng, tr√≠ch xu·∫•t m√†u            |

### 2.3.2 Brightness Changes ‚Äì Thay ƒë·ªïi ƒë·ªô s√°ng ·∫£nh
- ƒê·ªô s√°ng ·∫£nh c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh b·∫±ng c√°ch **c·ªông ho·∫∑c tr·ª´ m·ªôt gi√° tr·ªã s·ªë** v√†o t·ª´ng pixel.
- ·∫¢nh trong OpenCV l√† **NumPy array**, n√™n c√≥ th·ªÉ thao t√°c tr·ª±c ti·∫øp b·∫±ng c√°c ph√©p to√°n m·∫£ng.
- Ph·∫£i ƒë·∫£m b·∫£o pixel n·∫±m trong kho·∫£ng `[0, 255]` ‚Üí d√πng `np.clip()`.

**TƒÉng ƒë·ªô s√°ng (Increase brightness)**

√ù t∆∞·ªüng
- M·ªói pixel `I` ‚Üí `I_new = I + v`
- Sau ƒë√≥ d√πng `np.clip()` ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° `255`.

V√≠ d·ª•:
```python
import cv2
import numpy as np

img = cv2.imread('image.jpg')  # BGR
bright = img + 50
bright = np.clip(bright, 0, 255).astype(np.uint8)
```

**Gi·∫£m ƒë·ªô s√°ng (Decrease brightness)**

√ù t∆∞·ªüng:
- M·ªói pixel I ‚Üí I_new = I - v
- D√πng np.clip() ƒë·ªÉ kh√¥ng b·ªã √¢m (d∆∞·ªõi 0).

V√≠ d·ª•:
```python
dark = img - 50
dark = np.clip(dark, 0, 255).astype(np.uint8)
```

**M·ªôt s·ªë l∆∞u √Ω**
- OpenCV d√πng ·∫£nh ki·ªÉu uint8 (0‚Äì255).
- N·∫øu th·ª±c hi·ªán c·ªông/tr·ª´ tr√™n m·∫£ng uint8, v∆∞·ª£t ng∆∞·ª°ng s·∫Ω g√¢y l·ªói do tr√†n s·ªë.
- V√¨ v·∫≠y n√™n d√πng astype(np.int16) tr∆∞·ªõc khi t√≠nh to√°n, sau ƒë√≥ cast l·∫°i uint8.

V√≠ d·ª•: 
```python
img = img.astype(np.int16)
bright = np.clip(img + 100, 0, 255).astype(np.uint8)
```

# 3. ·ª®ng d·ª•ng 

# 4. Th·∫£o lu·∫≠n v√† m·ªü r·ªông 

# 5. K·∫øt lu·∫≠n

# 6. T√†i li·ªáu tham kh·∫£o
